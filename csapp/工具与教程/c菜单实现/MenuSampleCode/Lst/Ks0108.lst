C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 1   


C51 COMPILER V8.16, COMPILATION OF MODULE KS0108
OBJECT MODULE PLACED IN .\Obj\Ks0108.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE Src\Ks0108.C BROWSE DEBUG OBJECTEXTEND PRINT(.\Lst\Ks0108.lst) OBJECT(.\Obj
                    -\Ks0108.obj)

line level    source

   1          /******************************************************************************
   2           * Ks0108.C - Ks0108 液晶控制器驱动程序
   3           *
   4           *
   5           * DESCRIPTION: -
   6           *
   7           * modification history
   8           * --------------------
   9           * 01a, 04/sep/2007, 梁炎昌 written
  10           * --------------------
  11           ******************************************************************************/
  12          
  13          #include "CPU.H"
  14          #include "Ks0108.H"
  15          #include "Chinese.C"
  16          #include "ASCII.c"
  17          
  18          
  19          
  20          //------------------------------------------------------------------------------------------
  21          
  22          /*
  23          -------------------------------------------------------------------------
  24          GUI相关全局变量
  25          -------------------------------------------------------------------------
  26          */
  27          U8  GUIEnFont = En_8x16;                //英文字体
  28          U8  GUITextMode = GUI_TEXTMODE_NORMAL;  //显示模式
  29          
  30          U8 Char_XSIZE;   //英文字体X宽度
  31          U8 Char_YSIZE;   //英文字体Y宽度
  32          
  33          U8 PosX = 0;     //当前系统X坐标
  34          U8 PosY = 0;     //当前系统Y坐标
  35          
  36          U8 NoXY = true;//是否使用PosX PosY的标志   1-->不使用   0-->使用
  37          
  38          
  39          // ---- 延迟程序 ----------------------------------------------------
  40          #if OSC_48MHZ == true
  41          
  42          #define SomeNop();      {               \
  43              _nop_(); _nop_(); _nop_(); _nop_(); \
  44              _nop_(); _nop_(); _nop_(); _nop_(); \
  45             }
  46          
  47          #elif OSC_24MHZ == true
              
              #define SomeNop();      {               \
                  _nop_(); _nop_(); _nop_(); _nop_(); \
                  }
              
              #endif
  54          
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 2   

  55          
  56          
  57          
  58          
  59          
  60          /*
  61          *****************************************************************************
  62          * WriteCommand_0108 - 写命令到KS0108
  63          * DESCRIPTION: -
  64          * 本函数不接管片选信号
  65          * @Param CmdData:命令码
  66          * @Return :
  67          * ----
  68          *****************************************************************************
  69          */
  70          void WriteCommand_0108(U8 CmdData)
  71          {
  72   1          LCD_E = 0;
  73   1          LCD_RS = 0;
  74   1          LCD_RW = 0;
  75   1          LCD_Bus = CmdData;
  76   1          SomeNop();
  77   1          LCD_E = 1;
  78   1          SomeNop();
  79   1          LCD_E = 0;
  80   1      
  81   1      }
  82          
  83          
  84          /*
  85          *****************************************************************************
  86          * WriteData_0108 - 写数据到KS0108
  87          * DESCRIPTION: -
  88          * 本函数不接管片选信号
  89          * @Param Data:写入的数据
  90          * @Return :
  91          * ----
  92          *****************************************************************************
  93          */
  94          void WriteData_0108(U8 Data)
  95          {
  96   1          LCD_E = 0;
  97   1          LCD_RS = 1;
  98   1          LCD_RW = 0;
  99   1          LCD_Bus = Data;
 100   1          SomeNop();
 101   1          LCD_E = 1;
 102   1          SomeNop();
 103   1          LCD_E = 0;
 104   1      
 105   1      }
 106          /*-------------------读LCD数据----------------------------*/
 107          #if 0
              U8 ReadData_0108(void)
              {   U8 Temp;
                  LCD_Bus = 0xFF;//切换成输入
                  LCD_RS = 1;
                  LCD_RW = 1;
                  SomeNop();
                  LCD_E = 1;
                  SomeNop();
                  Temp = LCD_Bus;
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 3   

                  return(Temp);
              /*
                  U8 Temp;
                  PIN_KS0108_Di_HIGH;
                  PIN_KS0108_RW_HIGH;
                  DelayS(0);
                  PIN_KS0108_Enable_HIGH;
                  DelayS(0);
                  PIN_KS0108_Enable_LOW;
                  Temp = PIN_KS0108_Lcd_InBus;
                  return (Temp);
              */
              }
              
              U8 ReadState_0108(void)
              {
                  U8 Temp;
                  LCD_Bus = 0xFF;
                  LCD_RS = 0;
                  LCD_RW = 1;
                  SomeNop();
                  LCD_E = 1;
                  SomeNop();
                  LCD_E = 0;
                  Temp = LCD_Bus;
                  return (Temp);
              
              
              }
              
              U8 Busy(void)
              {
                  U16 TimeOut;
                  U8 Flag;
                  TimeOut = 200;
                  do{
                      Flag = ReadState_0108();
                      LED1 ^= 0x01;
                      if (TimeOut-- == 0){
                          return 0;
                      }
                  }while(Flag &0x80);
                  return 1;
              }
              #endif
 162          //Option = 1   --->Disp On
 163          //Option = 0   --->Disp Off
 164          void KS0108_DisplayOn(U8 Option)
 165          {
 166   1          if (Option == 1) {
 167   2              WriteCommand_0108(Ks0108_CMD_Disp_ON);
 168   2          }else{
 169   2              WriteCommand_0108(Ks0108_CMD_Disp_OFF);
 170   2          }
 171   1      }
 172          
 173          void KS0108_SetStartRow(U8 Row)
 174          {
 175   1          WriteCommand_0108(Ks0108_CMD_Disp_Start_Line + Row);
 176   1      }
 177          /*
 178          *****************************************************************************
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 4   

 179          * Display_Locate - LCD上指定位置 显示指定数据
 180          * DESCRIPTION: -
 181          *
 182          * @Param x0:0--191横向坐标
 183          * @Param y0:0--7  纵向坐标
 184          * @Param DisplayData:写入的数据
 185          * @Return :
 186          * ----
 187          *****************************************************************************
 188          */
 189          void Display_Locate(U8 DisplayData, U8 x0, U8 y0)
 190          {
 191   1          if ((x0 <= (LCD_XSIZE-1))&(y0 <= (LCD_YSIZE-1))){
 192   2              if (x0 <= 63){                                //0--191
 193   3                  LCD_CSA();
 194   3      //            Busy();//判忙
 195   3                  WriteCommand_0108(Ks0108_CMD_Set_Addr + x0);
 196   3              } else if (x0 <= 127){
 197   3                  LCD_CSB();
 198   3      //            Busy();//判忙
 199   3                  WriteCommand_0108(Ks0108_CMD_Set_Addr + x0 - 64);
 200   3              } else if (x0 <= 191){
 201   3                  LCD_CSC();
 202   3      //            Busy();//判忙
 203   3                  WriteCommand_0108(Ks0108_CMD_Set_Addr + x0 -128);
 204   3              }
 205   2      //        Busy();//判忙
 206   2              WriteCommand_0108(y0 + Ks0108_CMD_Set_Page);   //0--7
 207   2      //        Busy();//判忙
 208   2              WriteData_0108(DisplayData);
 209   2              LCD_CS_None();//不再片选任何一个Ks0108
 210   2          }
 211   1      }
 212          
 213          
 214          /*
 215          *****************************************************************************
 216          * Display_Clear - 清空LCD显示
 217          * DESCRIPTION: -
 218          *
 219          * @Param void:
 220          * @Return :
 221          * ----
 222          *****************************************************************************
 223          */
 224          void Display_Clear(void)
 225          {
 226   1          U8 j,k;
 227   1      //--------------------------------------
 228   1          LCD_CSA();
 229   1          for(k = 0; k < 8; k++){
 230   2              WriteCommand_0108(0 + Ks0108_CMD_Set_Addr); //0--7
 231   2              WriteCommand_0108(k + Ks0108_CMD_Set_Page); //0--63
 232   2              for(j = 0;j < 64;j++){
 233   3                  WriteData_0108(0x00);
 234   3              }
 235   2          }
 236   1          KS0108_SetStartRow(0);
 237   1      //--------------------------------------
 238   1          LCD_CSB();
 239   1          for(k = 0; k < 8; k++){
 240   2              WriteCommand_0108(0 + Ks0108_CMD_Set_Addr); //0--7
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 5   

 241   2              WriteCommand_0108(k + Ks0108_CMD_Set_Page); //0--63
 242   2              for(j = 0;j < 64;j++){
 243   3                  WriteData_0108(0x00);
 244   3              }
 245   2          }
 246   1          KS0108_SetStartRow(0);
 247   1      //-------------------------------------
 248   1          LCD_CSC();
 249   1          for(k = 0; k < 8; k++){
 250   2              WriteCommand_0108(0 + Ks0108_CMD_Set_Addr);//0--7
 251   2              WriteCommand_0108(k + Ks0108_CMD_Set_Page);//0-63
 252   2              for(j = 0;j < 64;j++){
 253   3                  WriteData_0108(0x00);
 254   3              }
 255   2          }
 256   1          KS0108_SetStartRow(0);
 257   1      //-------------------------------------
 258   1          LCD_CS_None();
 259   1      }
 260          
 261          
 262          /*
 263          *****************************************************************************
 264          * Display_Init - 初始化LCD
 265          * DESCRIPTION: -
 266          *
 267          * @Param void:
 268          * @Return :
 269          * ----
 270          *****************************************************************************
 271          */
 272          void Display_Init(void)
 273          {
 274   1      //---------------------------
 275   1          LCD_CSA();
 276   1          KS0108_DisplayOn(0);
 277   1          KS0108_SetStartRow(0);
 278   1          KS0108_DisplayOn(1);
 279   1      //---------------------------
 280   1          LCD_CSB();
 281   1          KS0108_DisplayOn(0);
 282   1          KS0108_SetStartRow(0);
 283   1          KS0108_DisplayOn(1);
 284   1      //---------------------------
 285   1          LCD_CSC();
 286   1          KS0108_DisplayOn(0);
 287   1          KS0108_SetStartRow(0);
 288   1          KS0108_DisplayOn(1);
 289   1      //---------------------------
 290   1          LCD_CS_None();
 291   1      }
 292          
 293          
 294          
 295          
 296          /*
 297          *****************************************************************************
 298          * Display_Chinese - 指定位置显示一个16x16的汉字
 299          * DESCRIPTION: -
 300          *
 301          * @Param x0:X轴坐标0--(192-16)
 302          * @Param y0:Y轴坐标0--(8-2)
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 6   

 303          * @Param UniCode:汉字内码
 304          * @Return :
 305          * ----
 306          *****************************************************************************
 307          */
 308          void Display_Chinese(U16 UniCode, U8 x0, U8 y0)
 309          {
 310   1        U16 CodeID;
 311   1        U8 i, ImgData;
 312   1        U8 HZ_X = x0;
 313   1        // 在字库里搜索汉字
 314   1          for(CodeID=0; CodeID < hzNum; CodeID++){
 315   2              // 找到 指定汉字的 Index 后, 跳出循环
 316   2              if ( (hzIndex[2*CodeID] == UniCode/256) && (hzIndex[2*CodeID+1] == UniCode%256) ){
 317   3                  break;
 318   3              }else if(CodeID == (hzNum-1)){//未检索到的汉字,显示个"##"提示吧
 319   3                  GUI_DispCharAt('#',x0,y0);
 320   3                  GUI_DispCharAt('#',x0+Char_XSIZE,y0);
 321   3                  return;
 322   3              }
 323   2          }
 324   1      //----------------------------------
 325   1          switch (GUITextMode) {
 326   2              case GUI_TEXTMODE_NORMAL :
 327   2      //-------------------------------------------------------------------------
 328   2                  // 写汉字的上半部分  (一个汉字 32 个字节,  显示为2行 * 16列)
 329   2                  for(i=0; i<16; i++){
 330   3                      ImgData = hzdot[i+CodeID*32];
 331   3                      Display_Locate(ImgData, HZ_X, y0);
 332   3                      HZ_X++;
 333   3                  }
 334   2                  // 写汉字的下半部分
 335   2                  HZ_X = x0;
 336   2                  for(i=16; i<32; i++){
 337   3                      ImgData = hzdot[i+CodeID*32];
 338   3                      Display_Locate(ImgData, HZ_X, y0 + 1);
 339   3                      HZ_X++;
 340   3                  }
 341   2      //-------------------------------------------------------------------------
 342   2                   break;
 343   2              case GUI_TEXTMODE_REVERSE :
 344   2      //-------------------------------------------------------------------------
 345   2                  // 写汉字的上半部分  (一个汉字 32 个字节,  显示为2行 * 16列)
 346   2                  for(i=0; i<16; i++){
 347   3                    ImgData = hzdot[i+CodeID*32]^0xFF;
 348   3                    Display_Locate(ImgData, HZ_X, y0);
 349   3                    HZ_X++;
 350   3                  }
 351   2                  // 写汉字的下半部分
 352   2                  HZ_X = x0;
 353   2                  for(i=16; i<32; i++){
 354   3                    ImgData = hzdot[i+CodeID*32]^0xFF;
 355   3                    Display_Locate(ImgData, HZ_X, y0 + 1);
 356   3                    HZ_X++;
 357   3                  }
 358   2      //-------------------------------------------------------------------------
 359   2                   break;
 360   2              case GUI_TEXTMODE_UNDERLINE :
 361   2      //-------------------------------------------------------------------------
 362   2                  // 写汉字的上半部分  (一个汉字 32 个字节,  显示为2行 * 16列)
 363   2                  for(i=0; i<16; i++){
 364   3                    ImgData = hzdot[i+CodeID*32];
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 7   

 365   3                    Display_Locate(ImgData, HZ_X, y0);
 366   3                    HZ_X++;
 367   3                  }
 368   2                  // 写汉字的下半部分
 369   2                  HZ_X = x0;
 370   2                  for(i=16; i<32; i++){
 371   3                    ImgData = hzdot[i+CodeID*32]|0x80;
 372   3                    Display_Locate(ImgData, HZ_X, y0 + 1);
 373   3                    HZ_X++;
 374   3                  }
 375   2      //-------------------------------------------------------------------------
 376   2                   break;
 377   2              default :
 378   2                   break;
 379   2          }
 380   1      }
 381          
 382          
 383          /*
 384          *****************************************************************************
 385          * Display_ASCII - 显示一个ASCII
 386          * DESCRIPTION: -
 387          *
 388          * @Param X:X轴坐标 0--192  (注意边界)
 389          * @Param Y:Y轴坐标 0-- 7   (注意边界)
 390          * @Param Char:ASCII码
 391          * @Return :
 392          * ----
 393          *****************************************************************************
 394          */
 395          void Display_ASCII(U8 Char, U8 X, U8 Y)
 396          {
 397   1          U8 i, ImgData;
 398   1          U8 HZ_X = X;
 399   1          if(GUIEnFont == En_5x8){
 400   2              Display_Locate(0x00, HZ_X, Y);
 401   2              HZ_X++;
 402   2              for(i = 0; i < 5; i++){
 403   3                  ImgData = chardot_5x8[i+(Char-0x20)*5];
 404   3                  Display_Locate(ImgData, HZ_X, Y);
 405   3                  HZ_X++;
 406   3              }
 407   2              Display_Locate(0x00, HZ_X, Y);
 408   2              HZ_X++;
 409   2              Display_Locate(0x00, HZ_X, Y);
 410   2          } else {
 411   2              for(i=0;i<8;i++){
 412   3                  ImgData = chardot_8x16[i+(Char-0x20)*16];
 413   3                  Display_Locate(ImgData, HZ_X, Y);
 414   3                  HZ_X++;
 415   3              }
 416   2              HZ_X=X;
 417   2              for(i=8;i<16;i++){
 418   3                  ImgData = chardot_8x16[i+(Char-0x20)*16];
 419   3                  Display_Locate(ImgData, HZ_X, Y + 1);
 420   3                  HZ_X++;
 421   3            }
 422   2      
 423   2         }
 424   1      }
 425          
 426          
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 8   

 427          
 428          
 429          /*
 430          *****************************************************************************
 431          * Display_InvASCII - 反显示ASCII
 432          * DESCRIPTION: -
 433          *
 434          * @Param X:X轴坐标  0--191
 435          * @Param Y:Y轴坐标  0--7
 436          * @Param Char:ASCII码
 437          * @Return :
 438          * ----
 439          *****************************************************************************
 440          */
 441          void Display_InvASCII(U8 Char, U8 X, U8 Y)
 442          {
 443   1      
 444   1          U8 i, ImgData;
 445   1          U8 HZ_X = X;
 446   1          if(GUIEnFont == En_5x8){
 447   2              Display_Locate(0xFF, HZ_X, Y);
 448   2              HZ_X++;
 449   2              for(i = 0; i < 5; i++){
 450   3                  ImgData = chardot_5x8[i+(Char-0x20)*5]^0xFF;
 451   3                  Display_Locate(ImgData, HZ_X, Y);
 452   3                  HZ_X++;
 453   3              }
 454   2              Display_Locate(0xFF, HZ_X, Y);
 455   2              HZ_X++;
 456   2              Display_Locate(0xFF, HZ_X, Y);
 457   2          } else {
 458   2              for(i=0;i<8;i++){
 459   3                  ImgData = chardot_8x16[i+(Char-0x20)*16] ^ 0xFF;
 460   3                  Display_Locate(ImgData, HZ_X, Y);
 461   3                  HZ_X++;
 462   3              }
 463   2              HZ_X=X;
 464   2              for(i=8;i<16;i++){
 465   3                  ImgData = chardot_8x16[i+(Char-0x20)*16] ^ 0xFF;
 466   3                  Display_Locate(ImgData, HZ_X, Y + 1);
 467   3                  HZ_X++;
 468   3              }
 469   2          }
 470   1      }
 471          
 472          /*
 473          *****************************************************************************
 474          * Display_ASCII_UnderLine - 显示一个带有下划线的ASCII
 475          * DESCRIPTION: -
 476          *
 477          * @Param X:X轴坐标
 478          * @Param Y:Y轴坐标
 479          * @Param Char:ASCII码
 480          * @Return :
 481          * ----
 482          *****************************************************************************
 483          */
 484          void Display_ASCII_UnderLine(U8 Char, U8 X, U8 Y)
 485          {
 486   1        //U16 Position;
 487   1        U8 i, ImgData;
 488   1        U8 HZ_X = X;
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 9   

 489   1          if(GUIEnFont == En_5x8){
 490   2              Display_Locate(0x80, HZ_X, Y);
 491   2              HZ_X++;
 492   2              for(i = 0; i < 5; i++){
 493   3                ImgData = chardot_5x8[i+(Char-0x20)*5] | 0x80;
 494   3                Display_Locate(ImgData, HZ_X, Y);
 495   3                HZ_X++;
 496   3              }
 497   2              Display_Locate(0x80, HZ_X, Y);
 498   2              HZ_X++;
 499   2              Display_Locate(0x80, HZ_X, Y);
 500   2          } else {
 501   2              for(i=0;i<8;i++){
 502   3                  ImgData = chardot_8x16[i+(Char-0x20)*16];
 503   3                  Display_Locate(ImgData, HZ_X, Y);
 504   3                  HZ_X++;
 505   3              }
 506   2              HZ_X=X;
 507   2              for(i=8;i<16;i++){
 508   3                  ImgData = chardot_8x16[i+(Char-0x20)*16] | 0x80;
 509   3                  Display_Locate(ImgData, HZ_X, Y + 1);
 510   3                  HZ_X++;
 511   3              }
 512   2          }
 513   1      }
 514          
 515          /*
 516          ----------------------------------------------------------------------------------------------
 517          
 518          ----------------------------------------------------------------------------------------------
 519          */
 520          #if 0
              /*
              ----------------------------------------------------------------------------------------------
              //移动当前Y坐标
              ----------------------------------------------------------------------------------------------
              */
              void GUI_GotoY(U8 y)
              {
                  if (y > 7) {
                      PosY = 7;
                  } else {
                      PosY = y;
                  }
              }
              /*
              ----------------------------------------------------------------------------------------------
              //移动当前Y坐标
              ----------------------------------------------------------------------------------------------
              */
              void GUI_GotoX(U8 x)
              {
                  if (x > 127) {
                      PosX = 127;
                  } else {
                      PosX = x;
                  }
              }
              /*
              *****************************************************************************
              * GUI_GotoXY - 系统光标移动到指定位置
              * DESCRIPTION: -
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 10  

              *
              * @Param y:Y轴坐标
              * @Param x:X轴坐标
              * @Return :
              * ----
              *****************************************************************************
              */
              void GUI_GotoXY(U8 x,U8 y)
              {
                  GUI_GotoX(x);
                  GUI_GotoY(y);
              }
              
              #endif
 565          /*
 566          *****************************************************************************
 567          * GUI_SetTextMode - 设置文字显示模式
 568          * DESCRIPTION: -
 569          *
 570          * @Param TextMode:模式代码
 571          * @Return :模式代码
 572          * ----
 573          *****************************************************************************
 574          */
 575          
 576          U8 GUI_SetTextMode(U8 TextMode)
 577          {
 578   1          GUITextMode = TextMode;
 579   1          return GUITextMode;
 580   1      }
 581          
 582          /*
 583          *****************************************************************************
 584          * GUI_SetEnFont - 设置显示的英文字体
 585          * DESCRIPTION: -
 586          * 目前支持两种字体8x16 5x8
 587          * @Param EnFont:字体代码
 588          * @Return :
 589          * ----
 590          *****************************************************************************
 591          */
 592          void GUI_SetEnFont(U8 EnFont)
 593          {
 594   1        if (EnFont == En_5x8){
 595   2          GUIEnFont = En_5x8;
 596   2          Char_XSIZE = En_5x8_XSIZE;
 597   2          Char_YSIZE = En_5x8_YSIZE;
 598   2        } else {
 599   2          GUIEnFont = En_8x16;
 600   2          Char_XSIZE = En_8x16_XSIZE;
 601   2          Char_YSIZE = En_8x16_YSIZE;
 602   2      
 603   2        }
 604   1      
 605   1      }
 606          /*
 607          ----------------------------------------------------------------------------------------------
 608          
 609          ----------------------------------------------------------------------------------------------
 610          */
 611          void GUI_Delay(U16 Period)
 612          {
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 11  

 613   1          U8 j;
 614   1          for (;  Period>0 ; Period--) {
 615   2              for (j = 0; j < 200; j++) {
 616   3              }
 617   2          }
 618   1      }
 619          /*
 620          *****************************************************************************
 621          * GUI_DispCharAt - 指定位置显示一个ASCII码
 622          * DESCRIPTION: - 字体使用是系统设定的字体
 623          *
 624          * @Param x:X轴坐标
 625          * @Param y:Y轴坐标
 626          * @Param c:ASCII码
 627          * @Return :
 628          * ----
 629          *****************************************************************************
 630          */
 631          void GUI_DispCharAt(U8 c, U8 x, U8 y)
 632          {
 633   1          switch (GUITextMode) {
 634   2              case GUI_TEXTMODE_NORMAL :
 635   2                   Display_ASCII(c, x, y);
 636   2                   break;
 637   2              case GUI_TEXTMODE_REVERSE :
 638   2                   Display_InvASCII(c, x, y);
 639   2                   break;
 640   2              case GUI_TEXTMODE_UNDERLINE :
 641   2                   Display_ASCII_UnderLine(c, x, y);
 642   2                   break;
 643   2              default :
 644   2                   break;
 645   2          }
 646   1      }
 647          /*
 648          ----------------------------------------------------------------------------------------------
 649          
 650          ----------------------------------------------------------------------------------------------
 651          */
 652          #if 0
              void GUI_DispChar(U8 c)
              {
                  GUI_DispCharAt(c, PosX, PosY);
                  PosX += 8;
              }
              #endif
 659          /*
 660          *****************************************************************************
 661          * GUI_Init - 初始化GUI显示
 662          * DESCRIPTION: -
 663          *
 664          * @Param void:
 665          * @Return :
 666          * ----
 667          *****************************************************************************
 668          */
 669          void GUI_Init(void)
 670          {
 671   1          Display_Init();
 672   1          GUIEnFont = En_8x16;
 673   1          GUITextMode = GUI_TEXTMODE_NORMAL;
 674   1          Char_XSIZE = En_8x16_XSIZE;
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 12  

 675   1          Char_YSIZE = En_8x16_YSIZE;
 676   1          PosX = 0;
 677   1          PosY = 0;
 678   1          NoXY = true;
 679   1      
 680   1      
 681   1      }
 682          void GUI_Clear(void)
 683          {
 684   1          Display_Clear();
 685   1      }
 686          #if 0
              void GUI_DispCEOL(void)
              {
                  U8 i;
                  for(i = PosX; i <= LCD_XSIZE-8; i += 8) {
                      GUI_DispCharAt(' ', i, PosY);
              
                  }
              }
              #endif
 696          /*
 697          *****************************************************************************
 698          * GUI_DispStringAt - 指定位置显示一个字符串
 699          * DESCRIPTION: -
 700          * 支持中英混合 当中英混合时英文字体强制为8x16 如果单单英文 按照设定字体
 701          * @Param x0:X轴坐标
 702          * @Param y0:Y轴坐标
 703          * @Param s:字符串
 704          * @Return :
 705          * ----
 706          *****************************************************************************
 707          */
 708          //void GUI_DispStringAt(U8 _CONST_ *s,U8 x0,U8 y0)
 709          void GUI_DispStringAt(U8 *s,U8 x0,U8 y0)
 710          {
 711   1          U8 i;
 712   1          if (NoXY == false){//没有提供坐标,则使用系统坐标
 713   2              x0 = PosX;
 714   2              y0 = PosY;
 715   2          }
 716   1          i = 0;
 717   1          while(s[i]!='\0'){
 718   2              if (s[i] < 0x80) {//是ASCII
 719   3                   if(s[i] == '\n'){
 720   4                          x0 = 0;
 721   4                          y0 += Char_YSIZE;
 722   4                   } else {
 723   4                      if (x0 > (LCD_XSIZE-1)) {//换行
 724   5                          x0 = 0;
 725   5                          y0 += Char_YSIZE;
 726   5                      }
 727   4                      switch (GUITextMode) {
 728   5                          case GUI_TEXTMODE_NORMAL :
 729   5                               Display_ASCII(s[i], x0, y0);
 730   5                               break;
 731   5                          case GUI_TEXTMODE_REVERSE :
 732   5                               Display_InvASCII(s[i], x0, y0);
 733   5                               break;
 734   5                          case GUI_TEXTMODE_UNDERLINE :
 735   5                               Display_ASCII_UnderLine(s[i], x0, y0);
 736   5                               break;
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 13  

 737   5                          default :
 738   5                               break;
 739   5                      }
 740   4                      x0 += Char_XSIZE;
 741   4                   }
 742   3              } else {//是中文
 743   3                  if (x0 > LCD_XSIZE-16){
 744   4                      x0 = 0;
 745   4                      y0 += Chinese_YSIZE;
 746   4                  }
 747   3                  Display_Chinese(s[i]*256+s[i+1],x0,y0);//中文
 748   3                  i++;
 749   3                  x0 += Chinese_XSIZE;
 750   3             }
 751   2             s++;
 752   2          }
 753   1          if (NoXY == false){
 754   2              PosX = x0;
 755   2              PosY = y0;
 756   2          }
 757   1      
 758   1      }
 759          #if 0
              /*
              *****************************************************************************
              * GUI_DispString - 在当前系统坐标下显示字符串
              * DESCRIPTION: -
              * 除了坐标不能指定外 功能跟GUI_DispStringAt一致
              * @Param s:字符串
              * @Return :
              * ----
              *****************************************************************************
              */
              void GUI_DispString(U8 _CONST_ *s)
              {
                  NoXY = false;
                  GUI_DispStringAt(s,PosX,PosY);
                  NoXY = true;
              }
              
              void GUI_DispStringLen(U8 _CONST_ *s, U16 Len)
              {
                  U8 i;
                  i = 0;
                  while(s[i]!='\0'){
                      if (i >= Len ){
                          return;
                      }
                      if (s[i] < 0x80) {//是ASCII
                           if(s[i] == '\n'){
              //                    PosX = 0;
              //                    PosY += 2;
                           } else {
                             if (PosX > (LCD_XSIZE-1)) {//换行
                                  PosX = 0;
              //                    PosY += 2;
                              }
                              switch (GUITextMode) {
                                  case GUI_TEXTMODE_NORMAL :
                                       Display_ASCII(s[i], PosX, PosY);
                                       break;
                                  case GUI_TEXTMODE_REVERSE :
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 14  

                                       Display_InvASCII(s[i], PosX, PosY);
                                       break;
                                  case GUI_TEXTMODE_UNDERLINE :
                                       Display_ASCII_UnderLine(s[i], PosX, PosY);
                                       break;
                                  default :
                                       break;
                              }
                              PosX += 8;
                           }
                      } else {//是中文
                          if (PosX > LCD_XSIZE-16){
              //                PosX = 0;
              //                PosY += 2;
                              return;
                          }
                          Display_Chinese(s[i]*256+s[i+1],PosX,PosY);//中文
                          i++;
                          PosX += 16;
                     }
                     i++;
                  }
              
              }
              
              void GUI_DrawCursor(U8 x, U8 y)
              {
                  if(GUITextMode == GUI_TEXTMODE_NORMAL){
                      Display_Locate(0xFF,x,y);
                      Display_Locate(0xFF,x,y+1);
                  } else if (GUITextMode == GUI_TEXTMODE_REVERSE){
                      Display_Locate(0x00,x,y);
                      Display_Locate(0x00,x,y+1);
                  } else {
                      Display_Locate(0xFF,x,y);
                      Display_Locate(0xFF,x,y+1);
                  }
              }
              
              void GUI_CursorOn(U8 x, U8 y)
              {
                  Display_Locate(0xFF,x,y);
                  Display_Locate(0xFF,x,y+1);
              }
              
              void GUI_CursorOFF(U8 x, U8 y)
              {
                  Display_Locate(0x00,x,y);
                  Display_Locate(0x00,x,y+1);
              }
              #endif
 850          
 851          /*
 852          *****************************************************************************
 853          * GUI_DispStringAtBar - 显示一个字符串在一个BAR中
 854          * DESCRIPTION: -
 855          * 可以设定对齐方式
 856          * @Param s:字符串
 857          * @Param x0:BAR起始X轴坐标
 858          * @Param x1:BAR结束点的X轴坐标
 859          * @Param y0:BAR的Y轴坐标
 860          * @Param Mode:对齐方式 居中于BAR 左对齐BAR 右对齐BAR
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 15  

 861          * @Return :
 862          * ----
 863          *****************************************************************************
 864          */
 865          //void GUI_DispStringAtBar(U8 _CONST_ *s,U8 x0, U8 y0, U8 x1,U8 Mode)
 866          void GUI_DispStringAtBar(U8 *s,U8 x0, U8 y0, U8 x1,U8 Mode)
 867          {
 868   1          U8 ENCount;//英文统计
 869   1          U8 CNCount;//中文统计
 870   1          U8 XLen;
 871   1          U8 X;
 872   1          U8 Y;
 873   1          U8 i;
 874   1          CNCount = 0;
 875   1          ENCount = 0;
 876   1          XLen = 0;
 877   1          i = 0;
 878   1          while(s[i]!='\0'){//统计中英文个数
 879   2              if (s[i] > 0x80) {
 880   3                  CNCount ++;
 881   3                  i++;
 882   3              } else {
 883   3                 ENCount++;
 884   3              }
 885   2              i++;
 886   2          }
 887   1              GUI_SetEnFont(En_8x16);
 888   1      /*
 889   1          if(CNCount){
 890   1              GUI_SetEnFont(En_8x16);
 891   1          } else {
 892   1              GUI_SetEnFont(En_5x8);
 893   1          }
 894   1      */
 895   1          XLen = ENCount*8 + CNCount*16;
 896   1      
 897   1          if (XLen > 127) {//我们只能显示一行
 898   2              XLen = 127;
 899   2          }
 900   1      //识别对其方式属性
 901   1          switch (Mode&0x30) {//只有这两个Bit是这个属性
 902   2              case GUI_TA_LEFT: //左对齐
 903   2                  XLen = 0;
 904   2                  break;
 905   2              case GUI_TA_HCENTER:  //居中
 906   2                  XLen  = ((x1-x0)-XLen)/2;
 907   2                  break;
 908   2              case GUI_TA_RIGHT:   //右对齐
 909   2                  XLen  = (x1-x0)-XLen;
 910   2                  break;
 911   2              default:
 912   2                  break;
 913   2          }
 914   1      //--------------------------------------
 915   1      //得到喀什显示的起点坐标
 916   1          X = x0+XLen;
 917   1          Y = y0;
 918   1      
 919   1      //---------------------
 920   1      //清除字符前面的空白部分
 921   1          if(Mode&GUI_JUST_TEXT){
 922   2          } else {
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 16  

 923   2              x0 = X;
 924   2              if (GUITextMode == GUI_TEXTMODE_REVERSE){
 925   3                  for(i = 0; i <x0; i++){
 926   4                      Display_Locate(0xFF, i,y0);
 927   4                      Display_Locate(0xFF, i,y0+1);
 928   4                  }
 929   3              }else{
 930   3                  for(i = 0; i <x0; i++){
 931   4                      Display_Locate(0x00, i,y0);
 932   4                      Display_Locate(0x00, i,y0+1);
 933   4                  }
 934   3              }
 935   2          }
 936   1      
 937   1      //-----------------------
 938   1          i = 0;
 939   1          while(s[i]!='\0'){
 940   2              if (s[i] < 0x80) {//是ASCII
 941   3                  switch (GUITextMode) {
 942   4                      case GUI_TEXTMODE_NORMAL :
 943   4                           Display_ASCII(s[i], X, Y);
 944   4                           break;
 945   4                      case GUI_TEXTMODE_REVERSE :
 946   4                           Display_InvASCII(s[i], X, Y);
 947   4                           break;
 948   4                      case GUI_TEXTMODE_UNDERLINE :
 949   4                           Display_ASCII_UnderLine(s[i], X, Y);
 950   4                           break;
 951   4                      default :
 952   4                           break;
 953   4                  }
 954   3                  X += 8;
 955   3              } else {//是中文
 956   3                  Display_Chinese(s[i]*256+s[i+1],X,Y);//中文
 957   3                  i++;
 958   3                  X += 16;
 959   3             }
 960   2      //       s++;
 961   2              i++;
 962   2          }
 963   1      //清除字符后面的空白部分
 964   1          if(Mode&GUI_JUST_TEXT){
 965   2              GUI_SetEnFont(En_5x8);
 966   2              return;
 967   2          } else {
 968   2              x0 = X;
 969   2              if (GUITextMode == GUI_TEXTMODE_REVERSE){
 970   3                  for(i = 0; i <x1-x0; i++){
 971   4                      Display_Locate(0xFF, x0+i,y0);
 972   4                      Display_Locate(0xFF, x0+i,y0+1);
 973   4                  }
 974   3              }else{
 975   3                  for(i = 0; i <x1-x0; i++){
 976   4                      Display_Locate(0x00, x0+i,y0);
 977   4                      Display_Locate(0x00, x0+i,y0+1);
 978   4                  }
 979   3              }
 980   2              GUI_SetEnFont(En_5x8);
 981   2              return;
 982   2          }
 983   1      //---------------------------------------
 984   1      }
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 17  

 985          
 986          #if 0
              //--------------------------
              //显示ASCII(16X32)
              //Char 字符
              //X 0--6
              //Y 0--(128-8)
              
              U16 _CONST_ Changedot[] =
              {
              0x0000, 0x0003, 0x000c, 0x000f, 0x0030, 0x0033, 0x003c, 0x003f, 0x00c0, 0x00c3,
              0x00cc, 0x00cf, 0x00f0, 0x00f3, 0x00fc, 0x00ff, 0x0300, 0x0303, 0x030c, 0x030f,
              0x0330, 0x0333, 0x033c, 0x033f, 0x03c0, 0x03c3, 0x03cc, 0x03cf, 0x03f0, 0x03f3,
              0x03fc, 0x03ff, 0x0c00, 0x0c03, 0x0c0c, 0x0c0f, 0x0c30, 0x0c33, 0x0c3c, 0x0c3f,
              0x0cc0, 0x0cc3, 0x0ccc, 0x0ccf, 0x0cf0, 0x0cf3, 0x0cfc, 0x0cff, 0x0f00, 0x0f03,
              0x0f0c, 0x0f0f, 0x0f30, 0x0f33, 0x0f3c, 0x0f3f, 0x0fc0, 0x0fc3, 0x0fcc, 0x0fcf,
              0x0ff0, 0x0ff3, 0x0ffc, 0x0fff, 0x3000, 0x3003, 0x300c, 0x300f, 0x3030, 0x3033,
              0x303c, 0x303f, 0x30c0, 0x30c3, 0x30cc, 0x30cf, 0x30f0, 0x30f3, 0x30fc, 0x30ff,
              0x3300, 0x3303, 0x330c, 0x330f, 0x3330, 0x3333, 0x333c, 0x333f, 0x33c0, 0x33c3,
              0x33cc, 0x33cf, 0x33f0, 0x33f3, 0x33fc, 0x33ff, 0x3c00, 0x3c03, 0x3c0c, 0x3c0f,
              0x3c30, 0x3c33, 0x3c3c, 0x3c3f, 0x3cc0, 0x3cc3, 0x3ccc, 0x3ccf, 0x3cf0, 0x3cf3,
              0x3cfc, 0x3cff, 0x3f00, 0x3f03, 0x3f0c, 0x3f0f, 0x3f30, 0x3f33, 0x3f3c, 0x3f3f,
              0x3fc0, 0x3fc3, 0x3fcc, 0x3fcf, 0x3ff0, 0x3ff3, 0x3ffc, 0x3fff, 0xc000, 0xc003,
              0xc00c, 0xc00f, 0xc030, 0xc033, 0xc03c, 0xc03f, 0xc0c0, 0xc0c3, 0xc0cc, 0xc0cf,
              0xc0f0, 0xc0f3, 0xc0fc, 0xc0ff, 0xc300, 0xc303, 0xc30c, 0xc30f, 0xc330, 0xc333,
              0xc33c, 0xc33f, 0xc3c0, 0xc3c3, 0xc3cc, 0xc3cf, 0xc3f0, 0xc3f3, 0xc3fc, 0xc3ff,
              0xcc00, 0xcc03, 0xcc0c, 0xcc0f, 0xcc30, 0xcc33, 0xcc3c, 0xcc3f, 0xccc0, 0xccc3,
              0xcccc, 0xcccf, 0xccf0, 0xccf3, 0xccfc, 0xccff, 0xcf00, 0xcf03, 0xcf0c, 0xcf0f,
              0xcf30, 0xcf33, 0xcf3c, 0xcf3f, 0xcfc0, 0xcfc3, 0xcfcc, 0xcfcf, 0xcff0, 0xcff3,
              0xcffc, 0xcfff, 0xf000, 0xf003, 0xf00c, 0xf00f, 0xf030, 0xf033, 0xf03c, 0xf03f,
              0xf0c0, 0xf0c3, 0xf0cc, 0xf0cf, 0xf0f0, 0xf0f3, 0xf0fc, 0xf0ff, 0xf300, 0xf303,
              0xf30c, 0xf30f, 0xf330, 0xf333, 0xf33c, 0xf33f, 0xf3c0, 0xf3c3, 0xf3cc, 0xf3cf,
              0xf3f0, 0xf3f3, 0xf3fc, 0xf3ff, 0xfc00, 0xfc03, 0xfc0c, 0xfc0f, 0xfc30, 0xfc33,
              0xfc3c, 0xfc3f, 0xfcc0, 0xfcc3, 0xfccc, 0xfccf, 0xfcf0, 0xfcf3, 0xfcfc, 0xfcff,
              0xff00, 0xff03, 0xff0c, 0xff0f, 0xff30, 0xff33, 0xff3c, 0xff3f, 0xffc0, 0xffc3,
              0xffcc, 0xffcf, 0xfff0, 0xfff3, 0xfffc, 0xffff,
              };
              bit EnFont = 0;
              void GUI_DispChar(U8 Char,U8 X,U8 Y,bit Nor)
              {
                  U8 i;
                  U8 dot;
              
                  U16 temp;
              
                  if(Y>(128-8)){//换行
                      X += 2;
                      Y  = 0;
                  }
                  if(!Nor){
                      for(i=0;i<8;i++){
                          if(EnFont == 0){
                              WriteByte(X,(Y+i),chardot[i+(Char-0x20)*16]);
                          }else{
                              dot = chardot[i+(Char-0x20)*16];
                              temp = Changedot[dot];
              //这段代码把字体纵向放大2倍,外部调用时换行需要加倍
                              WriteByte(X,(Y+i),(U8)(temp&0x00FF));
                              WriteByte(X+1,(Y+i),(U8)((temp&0xFF00)>>8));
              
              /*
              //这段代码把字体放大4倍,但由于横向轴被放大,因此外部调用函数时也需要加倍
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 18  

                              WriteByte(X,(Y+i*2),(U8)(temp&0x00FF));
                              WriteByte(X,(Y+i*2+1),(U8)(temp&0x00FF));
                              WriteByte(X+1,(Y+i*2),(U8)((temp&0xFF00)>>8));
                              WriteByte(X+1,(Y+i*2+1),(U8)((temp&0xFF00)>>8));
              */
                          }
              
                      }
                      for(i=8;i<16;i++){
                          if(EnFont == 0){
                              WriteByte(X+1,(Y+i-8),chardot[i+(Char-0x20)*16]);
                          }else{
                              dot = chardot[i+(Char-0x20)*16];
                              temp = Changedot[dot];
              
                              WriteByte(X+2,(Y+i-8),(U8)(temp&0x00FF));
                              WriteByte(X+3,(Y+i-8),(U8)((temp&0xFF00)>>8));
              
              /*
                              WriteByte(X+2,(Y+(i-8)*2),(U8)(temp&0x00FF));
                              WriteByte(X+2,(Y+(i-8)*2+1),(U8)(temp&0x00FF));
                              WriteByte(X+3,(Y+(i-8)*2),(U8)((temp&0xFF00)>>8));
                              WriteByte(X+3,(Y+(i-8)*2+1),(U8)((temp&0xFF00)>>8));
              */
                          }
                      }
                  }else{
                      for(i=0;i<8;i++){
                          if(EnFont == 0){
                              WriteByte(X,(Y+i),0xFF-chardot[i+(Char-0x20)*16]);
                          }else{
                              dot = 0xFF-chardot[i+(Char-0x20)*16];
                              temp = Changedot[dot];
                              WriteByte(X*2,(Y+i),(U8)(temp&0x00FF));
                              WriteByte(X*2,(Y+i+1),(U8)(temp&0x00FF));
                              WriteByte(X*2+1,(Y+i),(U8)((temp&0xFF00)>>8));
                              WriteByte(X*2+1,(Y+i+1),(U8)((temp&0xFF00)>>8));
              
                          }
                      }
                      for(i=8;i<16;i++){
                          if(EnFont == 0){
                              WriteByte(X+1,(Y+i-8),0xFF-chardot[i+(Char-0x20)*16]);
                          }else{
                              dot = 0xFF-chardot[i+(Char-0x20)*16];
                              temp = Changedot[dot];
                              WriteByte((X+1)*2,(Y+i-8+1),(U8)(temp&0x00FF));
                              WriteByte((X+1)*2,(Y+i-8),(U8)(temp&0x00FF));
                              WriteByte((X+1)*2+1,(Y+i-8+1),(U8)((temp&0xFF00)>>8));
                              WriteByte((X+1)*2+1,(Y+i-8),(U8)((temp&0xFF00)>>8));
                          }
                      }
                  }
              }
              #endif
1102          //--------------------------
1103          
1104          #if 0
              //-------------显示普通图片
              //------(图像 长度 起始位置)
              void Display_Image(U8 _CONST_ *IMG)
              {
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 19  

                  U8 XAddr;
                  U8 YAddr;
                  U16 Count;
                  Count = 0;
                  for(XAddr=0;XAddr<8;XAddr++){//0--7
                      for(YAddr=0;YAddr<128;YAddr++){//0--127
                          WriteByte(XAddr,YAddr,IMG[Count++]);
                      }
                  }
              }
              #endif
1120          
1121          /*
1122          *****************************************************************************
1123          * GUI_DrawIcon - 制定位置显示一个32x32的图标
1124          * DESCRIPTION: -
1125          *
1126          * @Param x0:X轴坐标
1127          * @Param y0:Y轴坐标 注意边界!
1128          * @Param Ico:图标数据
1129          * @Return :
1130          * ----
1131          *****************************************************************************
1132          */
1133          void GUI_DrawIcon(U8 _CONST_ *Ico,U8 x0,U8 y0)
1134          {
1135   1          U8 i;
1136   1          U16 Count;
1137   1          Count = 0;
1138   1          if( y0 > 4){//边界保护
1139   2              y0 = 4;
1140   2          }
1141   1          if(x0 >(LCD_XSIZE-32)){
1142   2              x0 = LCD_XSIZE-32;
1143   2          }
1144   1          for(i=0;i<32;i++){//第一行
1145   2              Display_Locate(Ico[Count++],x0+i,y0);
1146   2          }
1147   1          for(i=0;i<32;i++){//第二行
1148   2              Display_Locate(Ico[Count++],x0+i,y0+1);
1149   2          }
1150   1          for(i=0;i<32;i++){//第三行
1151   2              Display_Locate(Ico[Count++],x0+i,y0+2);
1152   2          }
1153   1          for(i=0;i<32;i++){//第四行
1154   2              Display_Locate(Ico[Count++],x0+i,y0+3);
1155   2          }
1156   1      }
1157          #if 0
              
              /*
              *****************************************************************************
              * GUI_DispDecAt - 显示十进制数值
              * DESCRIPTION: -
              * 处理长度最多5个数字(因为U16--->65536)
              * @Param v:显示的数据
              * @Param x:X轴坐标
              * @Param y:Y轴坐标  XY 均是起点位置坐标 也就是数值最高位的坐标
              * @Param Len:指定的显示长度1--5内
              * @Return :
              *
              *****************************************************************************
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 20  

              */
              void GUI_DispDecAt(U16 v, U16 x, U16 y, U8 Len)
              {
                  U8 i;
                  U8 CharBuf[5];
                  U8 HighByte;
              
                  HighByte = 0;
                  for(i = 0; i < 5; i++){
                      CharBuf[i] = (U8)(v%10);
                      v = v/10;
                      if(CharBuf[i]){
                          HighByte = i;
                      }
                  }
                  //第0位无论如何也显示
                  i = 0;
                  GUI_DispCharAt(CharBuf[i]+'0',x+((Len-1)-i)*Char_XSIZE,y);
                  for(i = 1; i < Len; i++){
                      if(CharBuf[i]){
                          GUI_DispCharAt(CharBuf[i]+'0',x+((Len-1)-i)*Char_XSIZE,y);
                      }else if(i > HighByte){
                          GUI_DispCharAt(' ',x+((Len-1)-i)*Char_XSIZE,y);
                      }
                  }
              
              }
              
              /*
              *****************************************************************************
              * GUI_DispHexAt - 显示一个数据的十六进制值
              * DESCRIPTION: -
              * 最大长度4个
              * @Param v:数据
              * @Param x:X轴坐标
              * @Param y:Y轴坐标  XY均是起点坐标 也就是数据最高字节坐标
              * @Param Len:长度1--4
              * @Return :
              *
              *****************************************************************************
              */
              void GUI_DispHexAt(U32 v, U8 x, U8 y, U8 Len)
              {
                  U8 i;
                  U8 HexData;
                  if(Len > 8){//限制范围
                      Len = 8;
                  }
                  for(i = 0; i < Len; i++){
                      HexData = v&0x0F;
                      v = v >>4;
                      if(HexData < 0x0A){
                          GUI_DispCharAt(HexData+'0',x+Char_XSIZE*(Len-1-i),y);
                      }else{
                          GUI_DispCharAt(HexData-0x0A+'A',x+Char_XSIZE*(Len-1-i),y);
                      }
                  }
              }
              /*
              *****************************************************************************
              * HBar - 显示一个水平的进度条
              * DESCRIPTION: -
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 21  

              * 附加有百分比显示
              * @Param x0:进度条起点X轴坐标   0-->127
              * @Param x1:进度条结束点X坐标   0-->127  必须大于x0  百分比显示于该坐标之后
              * @Param y:进度条Y轴坐标        0--7
              * @Param percent:当前百分值     0-->100
              * @Return :
              *
              *****************************************************************************
              */
              void HBar(U8 y, U8 x0, U8 x1,U8 percent)
              {
                  U8 U8Temp;
                  U8 i;
                  float Center;
                  Center = (x1-x0);
                  Center *= percent;
                  Center /= 100;
              //    U8Temp = (x1-x0)*percent/100;//这个计算做法在430上能用，但C51下似乎必须用浮点算
                  U8Temp = (U8)Center;
                  Display_Locate(0xFF, x0, y);
                  Display_Locate(0xFF, x1, y);
                  for(i = 1; i < U8Temp; i++){
                      Display_Locate(0xBD, x0+i, y);
                  }
                  for(i = x0+U8Temp+1; i < x1; i++){
                      Display_Locate(0x81, i, y);
                  }
              }
              /*                  x1 +3
              |-------------------|
              |                   ||
              |                   |||
              |                   ||||
              |                   ||||
              --------------------
               -------------------
                ------------------
              x0--->x1+3
              y0--->y1
              
              
              */
              
              void TipDisp( U8 x0, U8 y0, U8 x1, U8 y1)
              {
                  U8 i;
                  for(i = 0; i < x1-x0+4; i++){
                      Display_Locate(0x01, x0+i, y0);
                      Display_Locate(0x0F, x0+i, y1);
                  }
                  Display_Locate(0x01, x0+0, y1);
                  Display_Locate(0x01, x0+1, y1);
                  Display_Locate(0x03, x0+2, y1);
                  Display_Locate(0x03, x0+3, y1);
                  Display_Locate(0x07, x0+4, y1);
                  Display_Locate(0x07, x0+5, y1);
              
                  for(i = 0; i < y1-y0; i++){
                      Display_Locate(0xFF, x0, y0+i);
                      Display_Locate(0xFF, x1, y0+i);
                      Display_Locate(0xFF, x1+1, y0+i);
                      Display_Locate(0xFF, x1+2, y0+i);
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 22  

                      Display_Locate(0xFF, x1+3, y0+i);
                  }
                  Display_Locate(0xFC, x1+1, y0);
                  Display_Locate(0xF0, x1+2, y0);
                  Display_Locate(0xC0, x1+3, y0);
              }
              
              /*
              清空Tip
              坐标应该跟TipDisp一样
              */
              void TipClr( U8 x0, U8 y0, U8 x1, U8 y1)
              {
                  U8 i;
                  U8 j;
                  for(i = 0; i <= x1+3-x0; i++){
                      for(j = 0; j <= y1-y0; j++){
                          Display_Locate(0x00, x0+i, y0+j);
                      }
                  }
              
              }
              #endif
1318          /*
1319          // ---- 显示不带符号的整数  (数字 起始位置XY,显示长度) -----------------------------
1320          void Display_Number(U16 Number, U8 X, U8 Y, U8 Lenth)
1321          {
1322            U8 DispNum;
1323          
1324            X = ( X + Lenth * 8 - 8 );
1325            for(; Lenth>0; Lenth--)
1326            {
1327              DispNum = Number%10 + 0x30;
1328              Display_ASCII(DispNum, X, Y);
1329              X -= 8;
1330              Number = Number / 10;
1331            }
1332          }
1333          
1334          // ---- 显示带符号的整数  (数字 起始位置XY,显示长度) ---------------------------------
1335          void Display_SignedNumber(int Number,U8 X,U16 Y,U8 Lenth)
1336          {
1337            if(Number < 0)
1338            {
1339              Display_ASCII('-', X, Y);
1340              Display_Number(-Number, X+8, Y, Lenth);
1341            }
1342            else
1343            {
1344              Display_ASCII(' ', X, Y);
1345              Display_Number(Number, X+8, Y, Lenth);
1346            }
1347          }
1348          
1349          // ---- 显示不带符号的小数 (数字 起始位置XY,整数位数,小数位数) ------------------------------
1350          void Display_Decimal(unsigned long int Number, char X, U16 Y, U8 INT, U8 DEC)
1351          {
1352            U8 DispNum, Lenth;
1353            //Y = Y +(( X + INT * 8 + DEC * 8 ) / 84) * 2;
1354            X = ( X + ( INT + DEC ) *8);
1355            // 显示小数部分
1356            for(Lenth=DEC; Lenth>0; Lenth--)
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 23  

1357            {
1358              DispNum = Number%10 + 0x30;
1359              Display_ASCII(DispNum, X, Y);
1360              //if (X < 8) {Y -= 2; X += 84;}
1361              X -= 8;
1362              Number = Number / 10;
1363            }
1364            // 显示小数点
1365            Display_ASCII('.', X, Y);
1366            //if (X < 8) {Y -= 2; X += 84;}
1367              X -= 8;
1368            // 显示整数部分
1369            for(Lenth=INT; Lenth>0; Lenth--)
1370            {
1371              DispNum = Number%10 + 0x30;
1372              Display_ASCII(DispNum, X, Y);
1373              //if (X < 8) {Y -= 2; X += 84;}
1374              X -= 8;
1375              Number = Number / 10;
1376            }
1377          }
1378          
1379          // ---- 显示带符号的小数 (数字 起始位置XY,整数位数,小数位数) ------------------------------
1380          void Display_SignedDecimal(long int Number, char X, U16 Y, U8 INT, U8 DEC)
1381          {
1382            if(Number < 0)
1383            {
1384              Display_ASCII('-', X, Y);
1385              Display_Decimal(-Number, X+8, Y, INT, DEC);
1386            }
1387            else
1388            {
1389            Display_ASCII(' ',X,Y);
1390            Display_Decimal(Number, X+8, Y, INT, DEC);
1391            }
1392          }
1393          */
1394          
1395          
1396          //--------------
1397          /*
1398          Bar的算法
1399              ___
1400           |   |
1401           |   |
1402          | |<-|-----BarLen
1403           |   L
1404           |   |
1405           |   |
1406           |  _|_
1407          Bar的滑动距离是L-BarLen
1408          为了美观,可以在开始和结尾部分多流出来一些点,那么滑动距离要扣除这些点的长度,并在计算结果
1409          得到0的时候,添加上上端要留出来的点BarRemainDot
1410          2种显示方式:
1411          一种是BarLen是定长的,
1412          一种BarLen是根据显示总共的项数定下来的
1413          */
1414          
1415          
1416          //--------------
1417          //Bar的长度
1418          //预留出来的点
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 24  

1419          #define BarRemainDot  3
1420          //数字显示位置
1421          //#define BarNumPosX (128-8+2)
1422          #define BarNumPosY (7)
1423          //Bar的显示开始/结束位置
1424          //#define BarBeginPosX (126)
1425          #define BarBeginPosY (0*8)
1426          #define BarEndPosX (126)
1427          #define BarEndPosY (6*8)
1428          
1429          U8 _CONST_ BarCode0[]={0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00};
1430          U8 _CONST_ BarCode1[]={0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
1431          extern U8 ItemBackup_i;
1432          extern U8 ItemBackup[];
1433          
1434          void Bar(U8 Item_,U8 ItemNum_,U8 BarPosX,U8 BarNumPosX)
1435          {
1436   1          U8 U8_temp;
1437   1          U8 DispFlag;
1438   1          U8 YOffset;
1439   1          U16 Temp;
1440   1          U8 BarLen;
1441   1          U8 Y;
1442   1          U8 i;
1443   1      //    U8 CharBuf[5];
1444   1      //    Bool HighBit;
1445   1      
1446   1          BarLen = (BarEndPosY-BarBeginPosY-BarRemainDot)/(ItemNum_);//BarLen根据ItemNum_得到
1447   1          if (BarLen == 0) {
1448   2              BarLen = 5;
1449   2          }
1450   1          BarLen = 8;
1451   1          Temp = Item_*(BarEndPosY-BarBeginPosY-BarLen-BarRemainDot);//BarRemainDot是被扣除的部分
1452   1          Temp = Temp/(ItemNum_-1);
1453   1          YOffset = (U8)Temp;
1454   1          if(!Temp){//顶端，把预留的加上
1455   2              YOffset = BarRemainDot;
1456   2          }
1457   1      
1458   1          for(Y = 0;Y < BarEndPosY/8;Y++){
1459   2              if((Y != (YOffset/8))&&(Y != (YOffset/8+1))){
1460   3                  Display_Locate(0x00,BarPosX,Y);//清除 X=125 列
1461   3                  Display_Locate(0xFF,BarPosX+1,Y);//X=126列画线
1462   3                  Display_Locate(0x00,BarPosX+2,Y);//清除 X=127 列
1463   3              }else{//Y = YOffset/8 Y = YOffset/8＋1
1464   3                  Display_Locate(BarCode0[YOffset%8],BarPosX,(YOffset/8));
1465   3                  Display_Locate(0xFF-BarCode0[YOffset%8],BarPosX+1,(YOffset/8));
1466   3                  Display_Locate(BarCode0[YOffset%8],BarPosX+2,(YOffset/8));
1467   3                  if((YOffset/8)+1 < (BarEndPosY/8)){//防止下越界
1468   4                      Display_Locate(BarCode1[YOffset%8],BarPosX,(YOffset/8+1));
1469   4                      Display_Locate(0xFF-BarCode1[YOffset%8],BarPosX+1,(YOffset/8+1));
1470   4                      Display_Locate(BarCode1[YOffset%8],BarPosX+2,(YOffset/8+1));
1471   4                  }
1472   3              }
1473   2          }
1474   1      
1475   1          GUI_SetEnFont(En_5x8);
1476   1          Item_ += 1;
1477   1          //显示Bar数字
1478   1      /*
1479   1          for(i = 0; i < 5; i++){
1480   1              CharBuf[i] = (U8)(Item%10);
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 25  

1481   1              Item = Item/10;
1482   1          }
1483   1          HighBit = false;
1484   1          for(i = 0; i < 5; i++){
1485   1              if(CharBuf[4-i]){//从最高位开始显示
1486   1                  GUI_DispCharAt(CharBuf[4-i]+'0',x+8*i,y);
1487   1                  HighBit = true;
1488   1              }else{
1489   1                  if(HighBit == true){
1490   1                      GUI_DispCharAt('0',x+Char_XSIZE*i,y);//如果高位不为0,当前值为0 ,显示0
1491   1                  }
1492   1              }
1493   1          }
1494   1      */
1495   1          DispFlag = false;
1496   1          U8_temp = (U8)(Item_/100);//  百位
1497   1          if(U8_temp){
1498   2              GUI_DispCharAt(U8_temp+'0',BarNumPosX-12,BarNumPosY);
1499   2              DispFlag = true;//通知低位显示
1500   2          }else{
1501   2              GUI_DispCharAt(' ',BarNumPosX-12,BarNumPosY);
1502   2          }
1503   1      
1504   1          Item_ = (Item_-U8_temp*100);//剔除百位
1505   1          U8_temp = (U8)(Item_/10);//  十位
1506   1          if(U8_temp||(DispFlag == true)){//本位不为0，或者高位已经显示，那么必须显示
1507   2              GUI_DispCharAt(U8_temp+'0',BarNumPosX-6,BarNumPosY);
1508   2              DispFlag = 1;
1509   2          }else{
1510   2              GUI_DispCharAt(' ',BarNumPosX-6,BarNumPosY);
1511   2          }
1512   1      
1513   1          U8_temp = (U8)(Item_%10);//  个位
1514   1          GUI_DispCharAt(U8_temp+'0',BarNumPosX,BarNumPosY);
1515   1      
1516   1      //----------------------------------
1517   1      //显示历史索引号
1518   1          if(ItemBackup_i > 1){//大于1才是
1519   2              for(i = 0; i <ItemBackup_i-1;i++){//最后一个位于1的位置
1520   3                  Item_ = ItemBackup[ItemBackup_i-1-i]+1;  //从备份数据中得到标号，然后加1显示
1521   3                  U8_temp = (U8)(Item_%10);//
1522   3                  GUI_DispCharAt(U8_temp+'0',BarNumPosX-8*(i+1),BarNumPosY);
1523   3                  Display_Locate(0x10, BarNumPosX-8*(i+1)+8-1, BarNumPosY); //描分隔符
1524   3                  Display_Locate(0x10, BarNumPosX-8*(i+1)+8-0, BarNumPosY);
1525   3              }
1526   2          }
1527   1      //----------------------------------
1528   1          GUI_SetEnFont(En_8x16);
1529   1      
1530   1         return;
1531   1      
1532   1      }
1533          
1534          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2825    ----
   CONSTANT SIZE    =   4306    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      53
C51 COMPILER V8.16   KS0108                                                                12/15/2008 14:30:10 PAGE 26  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
